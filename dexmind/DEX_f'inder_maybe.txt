const { ethers } = require('ethers');
const axios = require('axios');
const db = require('../db/database');
const { DEX_SIGNATURES, DEX_PATTERNS } = require('./signatures');
const { sleep, normalizeAddress } = require('../utils/helpers');

// Initialize ethers provider
const provider = new ethers.providers.JsonRpcProvider(process.env.BASE_RPC_URL);

// Initial seed list of known DEXes on Base
const INITIAL_DEXES = [
  {
    name: 'Aerodrome',
    type: 'v2',
    factory_address: '0x420DD381b31aEf6683db6B902084cB0FFECe40Da',
    router_address: '0xcF77a3Ba9A5CA399B7c97c74d54e5b1Beb874E43'
  },
  {
    name: 'BaseSwap',
    type: 'v2',
    factory_address: '0xFDa619b6d20975be80A10332cD39b9a4b0FAa8BB',
    router_address: '0x327Df1E6de05895d2ab08513aaDD9313Fe505d86'
  },
  {
    name: 'RocketSwap',
    type: 'v2',
    factory_address: '0xD9a2AE5861Fe868bcdCE5d72AF735e9A04C1D0c0',
    router_address: '0x2626664c2603336E57B271c5C0b26F421741e481'
  },
  {
    name: 'Uniswap V3',
    type: 'v3',
    factory_address: '0x33128a8fC17869897dcE68Ed026d694621f6FDfD',
    router_address: '0x2626664c2603336E57B271c5C0b26F421741e481'
  }
];

// Major tokens to track for liquidity pool detection
const MAJOR_TOKENS = [
  // USDC
  '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913',
  // WETH
  '0x4200000000000000000000000000000000000006',
  // USDT
  '0x50c5725949a6f0c72e6c4a641f24049a917db0cb',
  // DAI
  '0x50c5725949a6f0c72e6c4a641f24049a917db0cb'
];

/**
 * Main scanning function that discovers DEXes on Base
 */
async function scanDexes(useCache = true) {
  console.log('Starting comprehensive DEX scan...');
  
  // Step 1: Start with initial seed DEXes
  for (const dex of INITIAL_DEXES) {
    await saveDex(dex);
  }
  
  // Step 2: Get cached results if requested
  if (useCache) {
    const cachedDexes = await getCachedDexes();
    if (cachedDexes && cachedDexes.length > 0) {
      console.log(`Using cached DEX data (${cachedDexes.length} DEXes)`);
      return cachedDexes;
    }
  }
  
  // Step 3: Scan for DEXes using token flow analysis
  await scanDexesByTokenFlow();
  
  // Step 4: Scan recently deployed contracts for DEX signatures
  await scanRecentContracts();
  
  // Step 5: Build relationships between components
  await buildDexRelationships();
  
  // Get final results
  const results = await db.query('SELECT * FROM dexes ORDER BY pair_count DESC');
  
  console.log(`DEX scan complete. Found ${results.rows.length} DEXes.`);
  return results.rows;
}

/**
 * Scan for DEXes by analyzing token transfers
 */
async function scanDexesByTokenFlow() {
  console.log('Scanning for DEXes using token flow analysis...');
  
  const currentBlock = await provider.getBlockNumber();
  const scanDepth = parseInt(process.env.SCAN_DEPTH) || 100000;
  const startBlock = currentBlock - scanDepth;
  
  for (const tokenAddress of MAJOR_TOKENS) {
    console.log(`Analyzing transfers for token ${tokenAddress}`);
    
    try {
      // Create token contract interface
      const tokenContract = new ethers.Contract(
        tokenAddress,
        ['event Transfer(address indexed from, address indexed to, uint256 value)'],
        provider
      );
      
      // Get transfer events
      const filter = tokenContract.filters.Transfer();
      const events = await tokenContract.queryFilter(filter, startBlock, currentBlock);
      
      console.log(`Found ${events.length} transfer events for ${tokenAddress}`);
      
      // Analyze destinations with significant transfers
      const destinations = {};
      for (const event of events) {
        const { to, value } = event.args;
        if (!destinations[to]) {
          destinations[to] = ethers.BigNumber.from(0);
        }
        destinations[to] = destinations[to].add(value);
      }
      
      // Check high-value destinations for DEX signatures
      const threshold = ethers.utils.parseEther(process.env.TOKEN_THRESHOLD || '1.0');
      for (const [dest, value] of Object.entries(destinations)) {
        if (value.gt(threshold)) {
          await checkContractForDex(dest);
        }
      }
      
      // Rate limiting for API calls
      await sleep(300);
      
    } catch (error) {
      console.error(`Error analyzing token ${tokenAddress}:`, error);
    }
  }
}

/**
 * Scan recently deployed contracts for DEX-like signatures
 */
async function scanRecentContracts() {
  console.log('Scanning recent contracts for DEX signatures...');
  
  try {
    const currentBlock = await provider.getBlockNumber();
    const scanDepth = parseInt(process.env.SCAN_DEPTH) || 100000;
    const apiKey = process.env.ETHERSCAN_API_KEY;
    
    // Use Basescan API to get contract creation transactions
    const url = `https://api.basescan.org/api?module=account&action=txlist&address=0x0000000000000000000000000000000000000000&startblock=${currentBlock - scanDepth}&endblock=${currentBlock}&sort=asc&apikey=${apiKey}`;
    
    const response = await axios.get(url);
    
    if (response.data.status === '1') {
      const contracts = response.data.result.filter(tx => 
        tx.input.length > 2 && 
        tx.isError === '0' && 
        tx.contractAddress !== ''
      );
      
      console.log(`Found ${contracts.length} contract creation transactions`);
      
      // Process contracts in batches to avoid rate limiting
      const batchSize = 10;
      for (let i = 0; i < contracts.length; i += batchSize) {
        const batch = contracts.slice(i, i + batchSize);
        
        await Promise.all(batch.map(tx => 
          checkContractForDex(tx.contractAddress)
        ));
        
        // Sleep between batches
        await sleep(1000);
      }
    }
  } catch (error) {
    console.error('Error scanning recent contracts:', error);
  }
}

/**
 * Check if a contract is a DEX component
 */
async function checkContractForDex(address) {
  address = normalizeAddress(address);
  
  try {
    // Check if we've already analyzed this contract
    const existing = await db.query(
      'SELECT * FROM contract_abis WHERE contract_address = $1',
      [address]
    );
    
    if (existing.rows.length > 0) {
      return existing.rows[0].contract_type === 'factory' || 
             existing.rows[0].contract_type === 'router';
    }
    
    // Get contract bytecode
    const bytecode = await provider.getCode(address);
    
    if (bytecode === '0x' || bytecode.length < 100) {
      return false; // Not a contract or empty contract
    }
    
    // Check for factory signatures
    for (const [name, signatures] of Object.entries(DEX_SIGNATURES.factory)) {
      let matchCount = 0;
      for (const sig of signatures) {
        if (bytecode.includes(sig.slice(2))) { // Remove 0x prefix
          matchCount++;
        }
      }
      
      // If most signatures match, likely a factory
      if (matchCount >= signatures.length * 0.7) {
        const dexInfo = {
          name: `Unknown ${name}`,
          type: name.includes('v3') ? 'v3' : 'v2',
          factory_address: address,
          first_seen_block: await getContractDeploymentBlock(address)
        };
        
        await saveDex(dexInfo);
        await saveContractABI(address, null, 'factory', false);
        return true;
      }
    }
    
    // Check for router signatures
    for (const [name, signatures] of Object.entries(DEX_SIGNATURES.router)) {
      let matchCount = 0;
      for (const sig of signatures) {
        if (bytecode.includes(sig.slice(2))) {
          matchCount++;
        }
      }
      
      if (matchCount >= signatures.length * 0.7) {
        await saveContractABI(address, null, 'router', false);
        return true;
      }
    }
    
    // Save contract as "other" to avoid rechecking
    await saveContractABI(address, null, 'other', false);
    return false;
    
  } catch (error) {
    console.error(`Error checking contract ${address}:`, error);
    return false;
  }
}

/**
 * Get pools for a specific factory
 */
async function getFactoryPairs(factoryAddress, limit = 100) {
  factoryAddress = normalizeAddress(factoryAddress);
  
  try {
    // Check for existing pools in database
    const existingPools = await db.query(
      'SELECT * FROM pools WHERE factory_address = $1 LIMIT $2',
      [factoryAddress, limit]
    );
    
    if (existingPools.rows.length > 0) {
      return existingPools.rows;
    }
    
    // Get factory DEX info
    const dexInfo = await db.query(
      'SELECT * FROM dexes WHERE factory_address = $1',
      [factoryAddress]
    );
    
    if (dexInfo.rows.length === 0) {
      throw new Error(`Factory not found: ${factoryAddress}`);
    }
    
    const dex = dexInfo.rows[0];
    
    // Use appropriate method based on DEX type
    let pools = [];
    if (dex.type === 'v2') {
      pools = await getV2Pairs(factoryAddress, limit);
    } else if (dex.type === 'v3') {
      pools = await getV3Pools(factoryAddress, limit);
    }
    
    // Save discovered pools
    for (const pool of pools) {
      await savePool(pool);
    }
    
    // Update pair count in dexes table
    await db.query(
      'UPDATE dexes SET pair_count = $1, updated_at = NOW() WHERE factory_address = $2',
      [pools.length, factoryAddress]
    );
    
    return pools;
    
  } catch (error) {
    console.error(`Error getting pairs for factory ${factoryAddress}:`, error);
    return [];
  }
}

/**
 * Get pairs for a V2 DEX
 */
async function getV2Pairs(factoryAddress, limit) {
  const pairs = [];
  
  try {
    // Create factory contract interface based on common V2 DEX patterns
    const factoryContract = new ethers.Contract(
      factoryAddress,
      [
        'function allPairsLength() view returns (uint)',
        'function allPairs(uint) view returns (address)',
        'function getPair(address, address) view returns (address)'
      ],
      provider
    );
    
    // Get total pair count
    const pairCount = await factoryContract.allPairsLength();
    const fetchCount = Math.min(parseInt(pairCount.toString()), limit);
    
    console.log(`Factory ${factoryAddress} has ${pairCount} pairs, fetching ${fetchCount}`);
    
    // Fetch pairs
    for (let i = 0; i// filepath: e:\Arby 2-22-25\Listonian-bot\base-dex-scanner\scanner\dexScanner.js
const { ethers } = require('ethers');
const axios = require('axios');
const db = require('../db/database');
const { DEX_SIGNATURES, DEX_PATTERNS } = require('./signatures');
const { sleep, normalizeAddress } = require('../utils/helpers');

// Initialize ethers provider
const provider = new ethers.providers.JsonRpcProvider(process.env.BASE_RPC_URL);

// Initial seed list of known DEXes on Base
const INITIAL_DEXES = [
  {
    name: 'Aerodrome',
    type: 'v2',
    factory_address: '0x420DD381b31aEf6683db6B902084cB0FFECe40Da',
    router_address: '0xcF77a3Ba9A5CA399B7c97c74d54e5b1Beb874E43'
  },
  {
    name: 'BaseSwap',
    type: 'v2',
    factory_address: '0xFDa619b6d20975be80A10332cD39b9a4b0FAa8BB',
    router_address: '0x327Df1E6de05895d2ab08513aaDD9313Fe505d86'
  },
  {
    name: 'RocketSwap',
    type: 'v2',
    factory_address: '0xD9a2AE5861Fe868bcdCE5d72AF735e9A04C1D0c0',
    router_address: '0x2626664c2603336E57B271c5C0b26F421741e481'
  },
  {
    name: 'Uniswap V3',
    type: 'v3',
    factory_address: '0x33128a8fC17869897dcE68Ed026d694621f6FDfD',
    router_address: '0x2626664c2603336E57B271c5C0b26F421741e481'
  }
];

// Major tokens to track for liquidity pool detection
const MAJOR_TOKENS = [
  // USDC
  '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913',
  // WETH
  '0x4200000000000000000000000000000000000006',
  // USDT
  '0x50c5725949a6f0c72e6c4a641f24049a917db0cb',
  // DAI
  '0x50c5725949a6f0c72e6c4a641f24049a917db0cb'
];

/**
 * Main scanning function that discovers DEXes on Base
 */
async function scanDexes(useCache = true) {
  console.log('Starting comprehensive DEX scan...');
  
  // Step 1: Start with initial seed DEXes
  for (const dex of INITIAL_DEXES) {
    await saveDex(dex);
  }
  
  // Step 2: Get cached results if requested
  if (useCache) {
    const cachedDexes = await getCachedDexes();
    if (cachedDexes && cachedDexes.length > 0) {
      console.log(`Using cached DEX data (${cachedDexes.length} DEXes)`);
      return cachedDexes;
    }
  }
  
  // Step 3: Scan for DEXes using token flow analysis
  await scanDexesByTokenFlow();
  
  // Step 4: Scan recently deployed contracts for DEX signatures
  await scanRecentContracts();
  
  // Step 5: Build relationships between components
  await buildDexRelationships();
  
  // Get final results
  const results = await db.query('SELECT * FROM dexes ORDER BY pair_count DESC');
  
  console.log(`DEX scan complete. Found ${results.rows.length} DEXes.`);
  return results.rows;
}

/**
 * Scan for DEXes by analyzing token transfers
 */
async function scanDexesByTokenFlow() {
  console.log('Scanning for DEXes using token flow analysis...');
  
  const currentBlock = await provider.getBlockNumber();
  const scanDepth = parseInt(process.env.SCAN_DEPTH) || 100000;
  const startBlock = currentBlock - scanDepth;
  
  for (const tokenAddress of MAJOR_TOKENS) {
    console.log(`Analyzing transfers for token ${tokenAddress}`);
    
    try {
      // Create token contract interface
      const tokenContract = new ethers.Contract(
        tokenAddress,
        ['event Transfer(address indexed from, address indexed to, uint256 value)'],
        provider
      );
      
      // Get transfer events
      const filter = tokenContract.filters.Transfer();
      const events = await tokenContract.queryFilter(filter, startBlock, currentBlock);
      
      console.log(`Found ${events.length} transfer events for ${tokenAddress}`);
      
      // Analyze destinations with significant transfers
      const destinations = {};
      for (const event of events) {
        const { to, value } = event.args;
        if (!destinations[to]) {
          destinations[to] = ethers.BigNumber.from(0);
        }
        destinations[to] = destinations[to].add(value);
      }
      
      // Check high-value destinations for DEX signatures
      const threshold = ethers.utils.parseEther(process.env.TOKEN_THRESHOLD || '1.0');
      for (const [dest, value] of Object.entries(destinations)) {
        if (value.gt(threshold)) {
          await checkContractForDex(dest);
        }
      }
      
      // Rate limiting for API calls
      await sleep(300);
      
    } catch (error) {
      console.error(`Error analyzing token ${tokenAddress}:`, error);
    }
  }
}

/**
 * Scan recently deployed contracts for DEX-like signatures
 */
async function scanRecentContracts() {
  console.log('Scanning recent contracts for DEX signatures...');
  
  try {
    const currentBlock = await provider.getBlockNumber();
    const scanDepth = parseInt(process.env.SCAN_DEPTH) || 100000;
    const apiKey = process.env.ETHERSCAN_API_KEY;
    
    // Use Basescan API to get contract creation transactions
    const url = `https://api.basescan.org/api?module=account&action=txlist&address=0x0000000000000000000000000000000000000000&startblock=${currentBlock - scanDepth}&endblock=${currentBlock}&sort=asc&apikey=${apiKey}`;
    
    const response = await axios.get(url);
    
    if (response.data.status === '1') {
      const contracts = response.data.result.filter(tx => 
        tx.input.length > 2 && 
        tx.isError === '0' && 
        tx.contractAddress !== ''
      );
      
      console.log(`Found ${contracts.length} contract creation transactions`);
      
      // Process contracts in batches to avoid rate limiting
      const batchSize = 10;
      for (let i = 0; i < contracts.length; i += batchSize) {
        const batch = contracts.slice(i, i + batchSize);
        
        await Promise.all(batch.map(tx => 
          checkContractForDex(tx.contractAddress)
        ));
        
        // Sleep between batches
        await sleep(1000);
      }
    }
  } catch (error) {
    console.error('Error scanning recent contracts:', error);
  }
}

/**
 * Check if a contract is a DEX component
 */
async function checkContractForDex(address) {
  address = normalizeAddress(address);
  
  try {
    // Check if we've already analyzed this contract
    const existing = await db.query(
      'SELECT * FROM contract_abis WHERE contract_address = $1',
      [address]
    );
    
    if (existing.rows.length > 0) {
      return existing.rows[0].contract_type === 'factory' || 
             existing.rows[0].contract_type === 'router';
    }
    
    // Get contract bytecode
    const bytecode = await provider.getCode(address);
    
    if (bytecode === '0x' || bytecode.length < 100) {
      return false; // Not a contract or empty contract
    }
    
    // Check for factory signatures
    for (const [name, signatures] of Object.entries(DEX_SIGNATURES.factory)) {
      let matchCount = 0;
      for (const sig of signatures) {
        if (bytecode.includes(sig.slice(2))) { // Remove 0x prefix
          matchCount++;
        }
      }
      
      // If most signatures match, likely a factory
      if (matchCount >= signatures.length * 0.7) {
        const dexInfo = {
          name: `Unknown ${name}`,
          type: name.includes('v3') ? 'v3' : 'v2',
          factory_address: address,
          first_seen_block: await getContractDeploymentBlock(address)
        };
        
        await saveDex(dexInfo);
        await saveContractABI(address, null, 'factory', false);
        return true;
      }
    }
    
    // Check for router signatures
    for (const [name, signatures] of Object.entries(DEX_SIGNATURES.router)) {
      let matchCount = 0;
      for (const sig of signatures) {
        if (bytecode.includes(sig.slice(2))) {
          matchCount++;
        }
      }
      
      if (matchCount >= signatures.length * 0.7) {
        await saveContractABI(address, null, 'router', false);
        return true;
      }
    }
    
    // Save contract as "other" to avoid rechecking
    await saveContractABI(address, null, 'other', false);
    return false;
    
  } catch (error) {
    console.error(`Error checking contract ${address}:`, error);
    return false;
  }
}

/**
 * Get pools for a specific factory
 */
async function getFactoryPairs(factoryAddress, limit = 100) {
  factoryAddress = normalizeAddress(factoryAddress);
  
  try {
    // Check for existing pools in database
    const existingPools = await db.query(
      'SELECT * FROM pools WHERE factory_address = $1 LIMIT $2',
      [factoryAddress, limit]
    );
    
    if (existingPools.rows.length > 0) {
      return existingPools.rows;
    }
    
    // Get factory DEX info
    const dexInfo = await db.query(
      'SELECT * FROM dexes WHERE factory_address = $1',
      [factoryAddress]
    );
    
    if (dexInfo.rows.length === 0) {
      throw new Error(`Factory not found: ${factoryAddress}`);
    }
    
    const dex = dexInfo.rows[0];
    
    // Use appropriate method based on DEX type
    let pools = [];
    if (dex.type === 'v2') {
      pools = await getV2Pairs(factoryAddress, limit);
    } else if (dex.type === 'v3') {
      pools = await getV3Pools(factoryAddress, limit);
    }
    
    // Save discovered pools
    for (const pool of pools) {
      await savePool(pool);
    }
    
    // Update pair count in dexes table
    await db.query(
      'UPDATE dexes SET pair_count = $1, updated_at = NOW() WHERE factory_address = $2',
      [pools.length, factoryAddress]
    );
    
    return pools;
    
  } catch (error) {
    console.error(`Error getting pairs for factory ${factoryAddress}:`, error);
    return [];
  }
}

/**
 * Get pairs for a V2 DEX
 */
async function getV2Pairs(factoryAddress, limit) {
  const pairs = [];
  
  try {
    // Create factory contract interface based on common V2 DEX patterns
    const factoryContract = new ethers.Contract(
      factoryAddress,
      [
        'function allPairsLength() view returns (uint)',
        'function allPairs(uint) view returns (address)',
        'function getPair(address, address) view returns (address)'
      ],
      provider
    );
    
    // Get total pair count
    const pairCount = await factoryContract.allPairsLength();
    const fetchCount = Math.min(parseInt(pairCount.toString()), limit);
    
    console.log(`Factory ${factoryAddress} has ${pairCount} pairs, fetching ${fetchCount}`);
    
    // Fetch pairs
    for (let i = 0; i